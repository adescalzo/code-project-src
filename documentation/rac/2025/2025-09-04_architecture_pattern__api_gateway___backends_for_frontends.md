```yaml
---
title: "Pattern: API Gateway / Backends for Frontends"
source: https://microservices.io/patterns/apigateway.html
date_published: unknown
date_captured: 2025-09-04T20:10:37.692Z
domain: microservices.io
author: Unknown
category: architecture
technologies: [Kong, REST, HTML5, Android, iPhone, Netflix API, Java, Spring, Netty, Spring Reactor, NodeJS, Spring Cloud Gateway, AMQP, gRPC]
programming_languages: [HTML5, JavaScript, Java]
tags: [microservices, api-gateway, application-architecture, inter-service-communication, rest-api, backends-for-frontends, service-discovery, reliability, security, patterns]
key_concepts: [Microservice architecture, API Gateway pattern, Backends for Frontends, REST APIs, Client-side Discovery, Server-side Discovery, Circuit Breaker, API Composition]
code_examples: false
difficulty_level: intermediate
summary: |
  [This article introduces the API Gateway pattern as a crucial component in microservice architectures, addressing how clients access multiple fine-grained services. It highlights challenges such as diverse client needs, network performance, and dynamic service locations, which the API Gateway solves by acting as a single entry point. The pattern allows for client-specific APIs, data aggregation, and protocol translation, simplifying client-side logic and improving user experience. A variation, Backends for Frontends, further refines this by providing dedicated gateways for different client types. While adding complexity, the API Gateway is essential for managing inter-service communication and insulating clients from the underlying microservice structure.]
---
```

# Pattern: API Gateway / Backends for Frontends

### Microservice Architecture

---

## Context

Let’s imagine you are building an online store that uses the [Microservice architecture pattern](microservices.html) and that you are implementing the product details page. You need to develop multiple versions of the product details user interface:

*   HTML5/JavaScript-based UI for desktop and mobile browsers - HTML is generated by a server-side web application
*   Native Android and iPhone clients - these clients interact with the server via REST APIs

In addition, the online store must expose product details via a REST API for use by 3rd party applications.

A product details UI can display a lot of information about a product. For example, the [Amazon.com](http://Amazon.com) details page for [POJOs in Action](http://www.amazon.com/POJOs-Action-Developing-Applications-Lightweight/dp/1932394583) displays:

*   Basic information about the book such as title, author, price, etc.
*   Your purchase history for the book
*   Availability
*   Buying options
*   Other items that are frequently bought with this book
*   Other items bought by customers who bought this book
*   Customer reviews
*   Sellers ranking
*   …

Since the online store uses the Microservice architecture pattern the product details data is spread over multiple services. For example,

*   Product Info Service - basic information about the product such as title, author
*   Pricing Service - product price
*   Order service - purchase history for product
*   Inventory service - product availability
*   Review service - customer reviews …

Consequently, the code that displays the product details needs to fetch information from all of these services.

## Problem

How do the clients of a Microservices-based application access the individual services?

## Forces

*   The granularity of APIs provided by microservices is often different than what a client needs. Microservices typically provide fine-grained APIs, which means that clients need to interact with multiple services. For example, as described above, a client needing the details for a product needs to fetch data from numerous services.
*   Different clients need different data. For example, the desktop browser version of a product details page desktop is typically more elaborate then the mobile version.
*   Network performance is different for different types of clients. For example, a mobile network is typically much slower and has much higher latency than a non-mobile network. And, of course, any WAN is much slower than a LAN. This means that a native mobile client uses a network that has very difference performance characteristics than a LAN used by a server-side web application. The server-side web application can make multiple requests to backend services without impacting the user experience where as a mobile client can only make a few.
*   The number of service instances and their locations (host+port) changes dynamically
*   Partitioning into services can change over time and should be hidden from clients
*   Services might use a diverse set of protocols, some of which might not be web friendly

## Solution

Implement an API gateway that is the single entry point for all clients. The API gateway handles requests in one of two ways. Some requests are simply proxied/routed to the appropriate service. It handles other requests by fanning out to multiple services.

![A diagram illustrating the API Gateway pattern. On the left, two client types (traditional server-side web application and browser/native app) interact with a central "API Gateway". The API Gateway acts as a "Single entry point" and provides "Client specific APIs". On the right, the API Gateway communicates with various backend microservices (Product Info service via REST, Recommendation Service via REST, Review service via AMQP), demonstrating "Protocol translation".](/i/apigateway.jpg)

Rather than provide a one-size-fits-all style API, the API gateway can expose a different API for each client. For example, the [Netflix API](http://techblog.netflix.com/2012/07/embracing-differences-inside-netflix.html) gateway runs client-specific adapter code that provides each client with an API that’s best suited to its requirements.

The API gateway might also implement security, e.g. verify that the client is authorized to perform the request

## Variation: Backends for frontends

A variation of this pattern is the Backends for frontends pattern. It defines a separate API gateway for each kind of client.

![A diagram illustrating the Backends for Frontends (BFF) pattern, a variation of the API Gateway. It shows three distinct client types (Web application, Mobile app, 3rd party applications), each interacting with its own dedicated API Gateway (Web app API Gateway, Mobile API Gateway, Public API Gateway). These client-specific gateways then fan out to common backend microservices (Catalog service via REST, Recommendation Service via REST, Review service via gRPC).](/i/bffe.png)

In this example, there are three kinds of clients: web application, mobile application, and external 3rd party application. There are three different API gateways. Each one is provides an API for its client.

## Examples

*   [Netflix API gateway](http://techblog.netflix.com/2013/01/optimizing-netflix-api.html)
*   A simple [Java/Spring API gateway](https://github.com/cer/event-sourcing-examples/tree/master/java-spring/api-gateway-service) from the [Money Transfer example application](https://github.com/cer/event-sourcing-examples).

## Resulting context

Using an API gateway has the following benefits:

*   Insulates the clients from how the application is partitioned into microservices
*   Insulates the clients from the problem of determining the locations of service instances
*   Provides the optimal API for each client
*   Reduces the number of requests/roundtrips. For example, the API gateway enables clients to retrieve data from multiple services with a single round-trip. Fewer requests also means less overhead and improves the user experience. An API gateway is essential for mobile applications.
*   Simplifies the client by moving logic for calling multiple services from the client to API gateway
*   Translates from a “standard” public web-friendly API protocol to whatever protocols are used internally

The API gateway pattern has some drawbacks:

*   Increased complexity - the API gateway is yet another moving part that must be developed, deployed and managed
*   Increased response time due to the additional network hop through the API gateway - however, for most applications the cost of an extra roundtrip is insignificant.

Issues:

*   How implement the API gateway? An event-driven/reactive approach is best if it must scale to scale to handle high loads. On the JVM, NIO-based libraries such as Netty, Spring Reactor, etc. make sense. NodeJS is another option.

## Related patterns

*   The [Microservice architecture pattern](microservices.html) creates the need for this pattern.
*   The API gateway must use either the [Client-side Discovery pattern](client-side-discovery.html) or [Server-side Discovery pattern](server-side-discovery.html) to route requests to available service instances.
*   The API Gateway may authenticate the user and pass an [Access Token](security/access-token.html) containing information about the user to the services
*   An API Gateway will use a [Circuit Breaker](reliability/circuit-breaker.html) to invoke services
*   An API gateway often implements the [API Composition pattern](/patterns/data/api-composition.html)

## Known uses

*   [Netflix API gateway](http://techblog.netflix.com/2012/07/embracing-differences-inside-netflix.html)

## Example application

See the API Gateway that part of my Microservices pattern’s [example application](https://github.com/microservice-patterns/ftgo-application). It’s implemented using Spring Cloud Gateway.

---

### Topics

Note: tagging is work-in-process

*   [Cynefin](/tags/Cynefin)
*   [DDD](/tags/DDD)
*   [GitOps](/tags/GitOps)
*   [Microservices adoption](/tags/Microservices adoption)
*   [ancient lore](/tags/ancient lore)
*   [anti-patterns](/tags/anti-patterns)
*   [api gateway](/tags/api gateway)
*   [application api](/tags/application api)
*   [application architecture](/tags/application architecture)
*   [architecting](/tags/architecting)
*   [architecture](/tags/architecture)
*   [architecture documentation](/tags/architecture documentation)
*   [assemblage](/tags/assemblage)
*   [automation](/tags/automation)
*   [beer](/tags/beer)
*   [books](/tags/books)
*   [build vs buy](/tags/build vs buy)
*   [containers](/tags/containers)
*   [culture](/tags/culture)
*   [dark energy and dark matter](/tags/dark energy and dark matter)
*   [decision making](/tags/decision making)
*   [deliberative design](/tags/deliberative design)
*   [deployment](/tags/deployment)
*   [deployment pipeline](/tags/deployment pipeline)
*   [design-time coupling](/tags/design-time coupling)
*   [developer experience](/tags/developer experience)
*   [development](/tags/development)
*   [devops](/tags/devops)
*   [docker](/tags/docker)
*   [eventuate platform](/tags/eventuate platform)
*   [fast flow](/tags/fast flow)
*   [generative AI](/tags/generative AI)
*   [glossary](/tags/glossary)
*   [health](/tags/health)
*   [hexagonal architecture](/tags/hexagonal architecture)
*   [implementing commands](/tags/implementing commands)
*   [implementing queries](/tags/implementing queries)
*   [inter-service communication](/tags/inter-service communication)
*   [kubernetes](/tags/kubernetes)
*   [loose coupling](/tags/loose coupling)
*   [manning publications](/tags/manning publications)
*   [microservice architecture](/tags/microservice architecture)
*   [microservice chassis](/tags/microservice chassis)
*   [microservices adoption](/tags/microservices adoption)
*   [microservices platforms](/tags/microservices platforms)
*   [microservices rules](/tags/microservices rules)
*   [microservicesio updates](/tags/microservicesio updates)
*   [modular monolith](/tags/modular monolith)
*   [multi-architecture docker images](/tags/multi-architecture docker images)
*   [observability](/tags/observability)
*   [pattern](/tags/pattern)
*   [pattern language](/tags/pattern language)
*   [patterns](/tags/patterns)
*   [refactoring](/tags/refactoring)
*   [refactoring to microservices](/tags/refactoring to microservices)
*   [resilience](/tags/resilience)
*   [runtime coupling](/tags/runtime coupling)
*   [sagas](/tags/sagas)
*   [scripting](/tags/scripting)
*   [security](/tags/security)
*   [service api](/tags/service api)
*   [service architecture](/tags/service architecture)
*   [service blueprint](/tags/service blueprint)
*   [service collaboration](/tags/service collaboration)
*   [service design](/tags/service design)
*   [service discovery](/tags/service discovery)
*   [service granularity](/tags/service granularity)
*   [service template](/tags/service template)
*   [software delivery metrics](/tags/software delivery metrics)
*   [success triangle](/tags/success triangle)
*   [survey](/tags/survey)
*   [tacos](/tags/tacos)
*   [team topologies](/tags/team topologies)
*   [technical debt](/tags/technical debt)
*   [testing](/tags/testing)
*   [transaction management](/tags/transaction management)
*   [transactional messaging](/tags/transactional messaging)
*   [wardley mapping](/tags/wardley mapping)

**[All content](/tags/index.html)**

---

### The patterns

[How to apply the patterns](/articles/applying.html)

Application architecture patterns

*   [Monolithic architecture](/patterns/monolithic.html)
*   [Microservice architecture](/patterns/microservices.html)

Decomposition

*   [Decompose by business capability](/patterns/decomposition/decompose-by-business-capability.html)
*   [Decompose by subdomain](/patterns/decomposition/decompose-by-subdomain.html)
*   [Self-contained Service](/patterns/decomposition/self-contained-service.html)
*   [Service per team](/patterns/decomposition/service-per-team.html)

Refactoring to microservices

*   [Strangler Application](/patterns/refactoring/strangler-application.html)
*   [Anti-corruption layer](/patterns/refactoring/anti-corruption-layer.html)

Data management

*   [Database per Service](/patterns/data/database-per-service.html)
*   [Shared database](/patterns/data/shared-database.html)
*   [Saga](/patterns/data/saga.html)
*   [Command-side replica](/patterns/data/command-side-replica.html)
*   [API Composition](/patterns/data/api-composition.html)
*   [CQRS](/patterns/data/cqrs.html)
*   [Domain event](/patterns/data/domain-event.html)
*   [Event sourcing](/patterns/data/event-sourcing.html)

Transactional messaging

*   [Transactional outbox](/patterns/data/transactional-outbox.html)
*   [Transaction log tailing](/patterns/data/transaction-log-tailing.html)
*   [Polling publisher](/patterns/data/polling-publisher.html)

Testing

*   [Service Component Test](/patterns/testing/service-component-test.html)
*   [Consumer-driven contract test](/patterns/testing/service-integration-contract-test.html)
*   [Consumer-side contract test](/patterns/testing/consumer-side-contract-test.html)

Deployment patterns

*   [Multiple service instances per host](/patterns/deployment/multiple-services-per-host.html)
*   [Service instance per host](/patterns/deployment/single-service-per-host.html)
*   [Service instance per VM](/patterns/deployment/service-per-vm.html)
*   [Service instance per Container](/patterns/deployment/service-per-container.html)
*   [Serverless deployment](/patterns/deployment/serverless-deployment.html)
*   [Service deployment platform](/patterns/deployment/service-deployment-platform.html)

Cross cutting concerns

*   [Microservice chassis](/patterns/microservice-chassis.html)
*   [Service Template](/patterns/service-template.html)
*   [Externalized configuration](/patterns/externalized-configuration.html)

Communication style

*   [Remote Procedure Invocation](/patterns/communication-style/rpi.html)
*   [Messaging](/patterns/communication-style/messaging.html)
*   [Domain-specific protocol](/patterns/communication-style/domain-specific.html)
*   [Idempotent Consumer](/patterns/communication-style/idempotent-consumer.html)

External API

*   [API gateway](/patterns/apigateway.html)
*   [Backend for front-end](/patterns/apigateway.html)

Service discovery

*   [Client-side discovery](/patterns/client-side-discovery.html)
*   [Server-side discovery](/patterns/server-side-discovery.html)
*   [Service registry](/patterns/service-registry.html)
*   [Self registration](/patterns/self-registration.html)
*   [3rd party registration](/patterns/3rd-party-registration.html)

Reliability

*   [Circuit Breaker](/patterns/reliability/circuit-breaker.html)

Security

*   [Access Token](/patterns/security/access-token.html)

Observability

*   [Log aggregation](/patterns/observability/application-logging.html)
*   [Application metrics](/patterns/observability/application-metrics.html)
*   [Audit logging](/patterns/observability/audit-logging.html)
*   [Distributed tracing](/patterns/observability/distributed-tracing.html)
*   [Exception tracking](/patterns/observability/exception-tracking.html)
*   [Health check API](/patterns/observability/health-check-api.html)
*   [Log deployments and changes](/patterns/observability/log-deployments-and-changes.html)

UI patterns

*   [Server-side page fragment composition](/patterns/ui/server-side-page-fragment-composition.html)
*   [Client-side UI composition](/patterns/ui/client-side-ui-composition.html)