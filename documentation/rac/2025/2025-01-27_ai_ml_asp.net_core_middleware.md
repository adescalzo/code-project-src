```yaml
---
title: ASP.NET Core Middleware
source: https://developmentwithadot.blogspot.com/2025/01/aspnet-core-middleware.html?utm_source=newsletter.csharpdigest.net&utm_medium=newsletter&utm_campaign=why-tracebit-is-written-in-c&_bhlid=bd76920c5ea0ab1e22dd29e0e989769a575f730d
date_published: 2025-01-27T07:22:00.000Z
date_captured: 2025-08-17T22:11:14.629Z
domain: developmentwithadot.blogspot.com
author: Visit profile
category: ai_ml
technologies: [ASP.NET Core, .NET, MVC, Minimal API]
programming_languages: [C#]
tags: [aspnet-core, middleware, web-development, http-pipeline, dotnet, web-api, request-processing, application-startup, dependency-injection, filters]
key_concepts: [asp.net-core-pipeline, middleware, requestdelegate, dependency-injection, short-circuiting, middleware-vs-filters, pipeline-branching, httpcontext]
code_examples: false
difficulty_level: intermediate
summary: |
  [This article provides a comprehensive guide to ASP.NET Core Middleware, explaining its fundamental role in the request processing pipeline. It details various implementation approaches, including inline, convention-based, and factory-activated middleware, highlighting their differences and appropriate use cases. The post also clarifies the distinction between middleware and MVC filters, and covers advanced topics like short-circuiting the pipeline and passing data between middleware components using HttpContext.Items. Furthermore, it explores different extension methods like Use, Map, Run, UseWhen, and MapWhen for conditional and branched pipeline configurations, making it a valuable resource for developers looking to deepen their understanding of ASP.NET Core.]
---
```

# ASP.NET Core Middleware

### ASP.NET Core Middleware

# Introduction

This post is another of those "back to basics", still, there was one thing or two that I feel were not properly discussed elsewhere, hence this post.

# The ASP.NET Core Pipeline and Middleware

You may know that ASP.NET Core defines a pipeline. This is where the incoming requests are processed and the response submitted. Each component in the pipeline - a middleware - can do things with the message (the request), such as check if it is authenticated and have rights to access the requested resource, turn the request into an MVC-style controller and action invocation, log it, and what not. You can read more about it [here](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware).

[![The ASP.NET Core pipeline](https://blogger.googleusercontent.com/img/a/AVvXsEjYkKMpywFcoK0ECjOJoIWvjseS56FYI5ax0-QM56EsTqm_RgvisNdoP2-Z2mRIpvZn7uCKkgtXFTnnBcbfsNXhWYDxxbHLn2mCYFvshLGOgde7Gm0pu6YG_tP0O8P2gTpewFZtia2gI4Q8yPi1V7GfsOyhu5TyJcYHqtnn_sLDuo1ybiCn91LzV4U_4TY=s16000 "The ASP.NET Core pipeline")](https://blogger.googleusercontent.com/img/a/AVvXsEjYkKMpywFcoK0ECjOJoIWvjseS56FYI5ax0-QM56EsTqm_RgvisNdoP2-Z2mRIpvZn7uCKkgtXFTnnBcbfsNXhWYDxxbHLn2mCYFvshLGOgde7Gm0pu6YG_tP0O8P2gTpewFZtia2gI4Q8yPi1V7GfsOyhu5TyJcYHqtnn_sLDuo1ybiCn91LzV4U_4TY)

The ASP.NET Core pipeline, from [Microsoft](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/)

The order by which the middleware is added to the pipeline matters. For example, the authorisation middleware must come after the authentication one, static files must come before routing, and exception handling must come before everything.

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjSaGEXuSz3ETL6JscyiJoa1p_Xgp4i-nuZzFuZvpM_VDXhXDSXg9ZYGzM5fjSMcO0vYkcqpKaWNIjRR9iAxe_kUzirNeci9SSJEh1DP0yt5buQykAC6dZVbencja0j8a3Wchyphenhyphenm4vwD9KK1JoNT05di2ah3fZK4tkQT4cpGJ-XUfE7ADUA6OGOpu-rEOdY/w613-h339/middleware-pipeline.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjSaGEXuSz3ETL6JscyiJoa1p_Xgp4i-nuZzFuZvpM_VDXhXDSXg9ZYGzM5fjSMcO0vYkcqpKaWNIjRR9iAxe_kUzirNeci9SSJEh1DP0yt5buQykAC6dZVbencja0j8a3Wchyphenhyphenm4vwD9KK1JoNT05di2ah3fZK4tkQT4cpGJ-XUfE7ADUA6OGOpu-rEOdY/s706/middleware-pipeline.png)

The middleware order, from [Microsoft](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/)

A middleware is just a piece of code that takes a context ([HttpContext](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext)) and a pointer to the next middleware in the pipeline (simplified). What it does is entirely up to us, some typical usages include:

*   Logging
*   Caching a response and retrieving from cache
*   Exception handling by wrapping the next middleware (and the others) on the pipeline
*   Timing the execution
*   Adding items to the request (headers, others)
*   Modifying the request somehow (redirecting, for example)
*   Etc, etc

Some caveats:

*   You cannot write to the response if the response has already been sent, must be careful as this results in an exception being thrown
*   Unless you want to short-circuit the pipeline (more later), you should always call the next middleware

The pipeline is declared as an [IApplicationBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder), and any middleware needs to be added to it before it is built ([Build](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder.build?view=aspnetcore-9.0#microsoft-aspnetcore-builder-iapplicationbuilder-build)).

Some included middleware components:

*   [AuthenticationMiddleware](https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Core/src/AuthenticationMiddleware.cs) ([UseAuthentication](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.authappbuilderextensions.useauthentication))
*   [AuthorizationMiddleware](https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Policy/src/AuthorizationMiddleware.cs) ([UseAuthorization](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.authorizationappbuilderextensions.useauthorization))
*   [EndpointRoutingMiddleware](https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/EndpointRoutingMiddleware.cs) ([UseRouting](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.userouting))
*   [ExceptionHandlerMiddleware](https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Diagnostics/src/ExceptionHandler/ExceptionHandlerMiddleware.cs) ([UseExceptionHandler](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.exceptionhandlerextensions.useexceptionhandler))
*   [HttpsRedirectionMiddleware](https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HttpsPolicy/src/HttpsRedirectionMiddleware.cs) ([UseHttpsRedirection](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.httpspolicybuilderextensions.usehttpsredirection))
*   [RateLimitingMiddleware](https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/RateLimiting/src/RateLimitingMiddleware.cs) ([UseRateLimiter](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.ratelimiterapplicationbuilderextensions.useratelimiter))
*   [RewriteMiddleware](https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Rewrite/src/RewriteMiddleware.cs) ([UseRewriter](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.rewritebuilderextensions.userewriter))
*   [StaticFileMiddleware](https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/src/StaticFileMiddleware.cs) ([UseStaticFiles](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.staticfileextensions.usestaticfiles))
*   [OutputCacheMiddleware](https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/OutputCaching/src/OutputCacheMiddleware.cs) ([UseOutputCache](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.outputcacheapplicationbuilderextensions.useoutputcache))

As I said, the order by which a middleware component is added matters. Just thing, for example, that the static files middleware retrieves existing files (real URLs) before endpoint mapping (virtual URLs) steps in, and authorization needs authentication first.

# Middleware vs Filters

One common question is: why use middleware if we have [filters](https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters)? Well, middleware applies to the request pipeline, and is therefore applicable to all requests, whereas filters belong to [MVC](https://learn.microsoft.com/en-us/aspnet/core/mvc/overview), and in general, apply to an action method or controller (although we can have [global filters](https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-9.0#filter-scopes-and-order-of-execution) too). Filters apply to an MVC specific request, and have access, for example, to an action method's [model](https://learn.microsoft.com/en-us/aspnet/core/mvc/models/model-binding), whereas middleware is more high level.

# Inline Middleware

The easiest way to add middleware to the pipeline is through the [Use](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder.use?view=aspnetcore-8.0#microsoft-aspnetcore-builder-iapplicationbuilder-use\(system-func\(\(microsoft-aspnetcore-http-requestdelegate-microsoft-aspnetcore-http-requestdelegate\)\)\)) extension method over [IApplicationBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder). This is before the pipeline is actually built, and, remember, the order matters!

```csharp
app.Use(static async (context, next) =>
{
    await context.Response.WriteAsync("Hello world from an inline middleware!");
    await next(context);
});
```

In a moment, I'll show you other ways to add middleware with just a delegate.

# Convention-based Middleware

Another option is to have a class that contains the logic we wish to add to the pipeline, which is arguably a better option for more complex code. If we so want it, any [POCO](https://en.wikipedia.org/wiki/Plain_old_CLR_object) class will do, ASP.NET Core will use a convention to invoke it. This kind of middleware is added by the [UseMiddleware](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.usemiddlewareextensions.usemiddleware) method, again, before the pipeline is built:

```csharp
internal class ConventionalMiddleware(RequestDelegate next)
{
    public async Task InvokeAsync(HttpContext context, IMyType myType)
    {
        //do something
        await next(context);
    }
}

//...

app.UseMiddleware<ConventionalMiddleware>(new MyType());
```

As you can see, there is no base class or interface that needs to be implemented, just some vanilla class, its only requirements are;

*   That it is not abstract
*   Has a constructor that receives a [RequestDelegate](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.requestdelegate) object, along with possibly others
*   Has a public method called **InvokeAsync** that returns a [Task](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task), and takes as its first (and possibly only) parameter an [HttpContext](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext)

A [RequestDelegate](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.requestdelegate) is just delegate class that points to the next middleware on the pipeline. Additional paremeters to the constructor or the **InvokeAsync** method are obtained from the **InvokeAsync** method's optional parameters, or from the DI container. Its a common practice to store the pointer to the [RequestDelegate](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.requestdelegate) injected on the constructor and use it in **InvokeAsync** to call the next middleware on the pipeline.

To make it more dynamic, there is an overload to [UseMiddleware](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.usemiddlewareextensions.usemiddleware) that takes a [Type](https://learn.microsoft.com/en-us/dotnet/api/system.type):

```csharp
app.UseMiddleware(typeof(ConventionalMiddleware), new MyType());
```

As you can see, you can also pass any additional parameter here.

Now, you can do things before and after calling the next middleware component:

```csharp
internal class StopWatchMiddleware(RequestDelegate next, ILogger<StopWatchMiddleware> logger)
{
    public async Task InvokeAsync(HttpContext context)
    {
        var timer = new StopWatch();
        timer.Start();
        await next(context);
        logger.LogDebug("The processing of the pipeline took {Elapsed}", timer.Elapsed);
    }
}
```

Some common usages include logging, exception handling, and timing.

Now, because a middleware component is constructed at application startup, it essentially is a singleton, which means its constructor cannot take scoped services. For that, you have the option to pass them in the **InvokeAsync** method, this is the essential difference between passing services in the constructor versus **InvokeAsync**.

# Factory-Activated Middleware

There is another kind of middleware type that you can register, only this time it needs to implement an interface. This interface is [IMiddleware](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.imiddleware), and it only defines an [InvokeAsync](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.imiddleware.invokeasync?view=aspnetcore-9.0#microsoft-aspnetcore-http-imiddleware-invokeasync\(microsoft-aspnetcore-http-httpcontext-microsoft-aspnetcore-http-requestdelegate\)) method, this time, with two fixed parameters:

```csharp
internal class FactoryActivatedMiddleware(IMyType myType) : IMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        //do something
        await next(context);
    }
}

//...

builder.Services.AddSingleton<FactoryActivatedMiddleware>();
app.UseMiddleware<FactoryActivatedMiddleware>();
```

Registration is done the same way, using [UseMiddleware](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.usemiddlewareextensions.usemiddleware), the only difference is that the [IMiddleware](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.imiddleware) class must be registered with the DI container and will be instantiated by it. All the rest, including the possibility to inject values from the constructor (not from the [InvokeAsync](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.imiddleware.invokeasync?view=aspnetcore-9.0#microsoft-aspnetcore-http-imiddleware-invokeasync\(microsoft-aspnetcore-http-httpcontext-microsoft-aspnetcore-http-requestdelegate\)) method!) is the same.

# Convention vs Factory-Activated Middleware

In general, convention-based middleware (no base interface) is created once when starting the ASP.NET Core application, while factory-activated ([IMiddleware](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.imiddleware)) is created with each request, but, one can select the lifetime for it, as it must be registered with DI. Factory-based middleware supports [Scoped](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scoped) lifetime, if we so register them, which means we can inject scoped services into its constructor, but in general they should be registered as [Singleton](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#singleton). [IMiddleware](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.imiddleware) is also, of course, strongly typed, other than that, they are pretty much similar.

# Middleware Factories

Factory-activated ([IMiddleware](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.imiddleware)) middleware, as its name says, is built by a [middleware factory](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/extensibility). A middleware factory is just an implementation of [IMiddlewareFactory](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.imiddlewarefactory) that is registered on the DI container. The default implementation just retrieves the middleware from DI, but you can change this. Just register your own implementation of [IMiddlewareFactory](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.imiddlewarefactory) with the [Scoped](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scoped) lifetime, and implement it any way you want. Convention-based are instantiated using [ActivatorUtilities.CreateInstance](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.activatorutilities.createinstance).

# Middleware Dependencies

From the [Microsoft documentation](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/write): Middleware should follow the [Explicit Dependencies Principle](https://learn.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#explicit-dependencies) by exposing its dependencies in its constructor. Middleware is constructed once per application lifetime.

Middleware components can resolve their dependencies from [dependency injection (DI)](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection?view=aspnetcore-9.0) through constructor parameters. [UseMiddleware](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.usemiddlewareextensions.usemiddleware) can also accept additional parameters directly, which will be passed to **InvokeAsync**.

Because dependencies are instantiated at app startup, the only way to inject [scoped dependencies](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scoped) is to add them as parameters to the **InvokeAsync** method, for convention-based middleware.

For both kinds of middleware, you can obviously retrieve services from the DI container from [HttpContext.RequestServices](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.requestservices).

# Adding Middleware from a Startup Filter

Another way to add a middleware component is from a [startup filter](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/startup#extend-startup-with-startup-filters) ([IStartupFilter](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.istartupfilter)). We can do this by calling [ConfigureServices](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilder.configureservices) on the host before the pipeline is built:

```csharp
internal class MiddlewareStartupFilter : IStartupFilter
{
    public Action<IApplicationBuilder> Configure(Action<IApplicationBuilder> next)
    {
        return app =>
        {
            app.Use(static async (ctx, next) =>
            {
                await next(ctx);
            });
            next(app);
        };
    }
}

//..

builder.Host.ConfigureServices((ctx, services) =>
{
    services.AddSingleton<IStartupFilter, MiddlewareStartupFilter>();
});

//...

var app = builder.Build();
app.Run();
```

This will add to the beginning of the pipeline, as startup filters execute very early in the pipeline build process.

# Adding Middleware from a Filter Attribute

Another option to add some middleware to the pipeline is through the [[MiddlewareFilter]](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.middlewarefilterattribute) attribute. This allows adding to the beginning of the pipeline, in pretty much the same way as calling [ConfigureServices](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilder.configureservices) on the host:

```csharp
[MiddlewareFilter<MiddlewarePipeline>]
//[MiddlewareFilter(typeof(MiddlewarePipeline))]
public class HomeController : Controler { ... }


internal class MiddlewarePipeline
{
    public void Configure(IApplicationBuilder appBuilder)
    {
        appBuilder.UseMiddleware<SomeMiddleware>();
    }
}
```

# Short-circuiting Middleware

If we want to short-circuit (stop the execution of all) the next middleware components on the pipeline, we can skip calling the **next** delegate. For example:

```csharp
internal class ShortCircuitingMiddleware : IMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        //do something
        if (/*NormalCondition*/) await next(context);
        //pipeline ends here if some condition is not met
        context.Response.StatusCode = StatusCodes.Status503ServiceUnavailable;
        await context.Response.WriteAsync("Something happened - unavailable");
    }
}
```

When you short-circuit a response, make sure you return the appropriate status code and possibly some response, otherwise, the calling party won't know what happened.

# Sending Responses

Besides doing server-side operations, you can also modify the response from a middleware component - send contents ([HttpResponse.Body](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresponse.headers#microsoft-aspnetcore-http-httpresponse-body)), modify headers ([HttpResponse.Headers](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresponse.headers#microsoft-aspnetcore-http-httpresponse-headers)). You just need to be certain that the response hasn't yet begun - in which case, you cannot modify the headers - or if it has been sent altogether.

In order to find out if the message has begun to be sent, you can check the [HttpResponse.HasStarted](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresponse.hasstarted) property, and also in the [IHttpResponseFeature](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresponse) [request feature](https://weblogs.asp.net/ricardoperes/asp-net-core-features) [HasStarted](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.features.ihttpresponsefeature.hasstarted) property:

```csharp
public async Task InvokeAsync(HttpContext context, RequestDelegate next)
{
    if (!context.Response.HasStarted)
    {
        context.Response.Headers["From"] = "Middleware";
        await context.Response.WriteAsync("Hello, World!");
    }
    await next(context);
}
```

# Passing Data Between Middleware Components

A common request is to pass, share, data between middleware components. This can be useful, for example, to know if some middleware has been executed. The way I see it, there are three ways to do this:

*   Using a [Scoped](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scoped) service that can store data
*   Using a [request feature](https://weblogs.asp.net/ricardoperes/asp-net-core-features) that also stores data
*   Using [HttpContext.Items](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.items) to store keyed data

You know you should avoid storing data in static fields, in most cases. Best option, IMO, is #3, as you don't really need to implement anything, it is by key, lasts for the whole request and no further, and can store any kind of object. Just make sure you choose a key that is unique enough. A couple examples:

```csharp
//Middleware M1
public const string MyKey = "__MyKey";


public async Task InvokeAsync(HttpContext ctx, RequestDelegate next)
{
    ctx.Items[MyKey] = "Some Secret Value";
    ctx.Items["M1"] = true;
    //...
}


//Middleware M2
public async Task InvokeAsync(HttpContext ctx, RequestDelegate next)
{
    if (ctx.Items[MyKey] is string key)
    {
        //...
    }
    //...
}
```

# Use, Map, Run Extension Methods

In the beginning, I mentioned the [Use](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder.use?view=aspnetcore-8.0#microsoft-aspnetcore-builder-iapplicationbuilder-use\(system-func\(\(microsoft-aspnetcore-http-requestdelegate-microsoft-aspnetcore-http-requestdelegate\)\)\)) extension method over [IApplicationBuilder](https://learn.microsoft.com/