```yaml
---
title: "How I Analyze Slow Database Queries in My C# Projects | by Kittikawin L. üçÄ | Jul, 2025 | Medium"
source: https://medium.com/@kittikawin_ball/how-i-analyze-slow-database-queries-in-my-c-projects-80d50265bb96
date_published: 2025-07-10T09:01:22.978Z
date_captured: 2025-08-22T10:48:42.052Z
domain: medium.com
author: Kittikawin L. üçÄ
category: database
technologies: [Entity Framework Core, SQL Server, ASP.NET Core, Azure Data Studio, pgAdmin, MySQL Workbench, MiniProfiler, EFCore.BulkExtensions, Application Insights, New Relic, Dynatrace, SQL Server Profiler, Azure Query Performance Insight, .NET]
programming_languages: [C#, SQL]
tags: [database, performance, sql-optimization, ef-core, dotnet, query-analysis, debugging, web-api, data-access, profiling]
key_concepts: [query-optimization, execution-plans, indexing, n+1-problem, logging, performance-monitoring, data-pagination, database-bottleneck]
code_examples: false
difficulty_level: intermediate
summary: |
  [This article outlines a practical workflow for identifying, analyzing, and fixing slow database queries in C# projects. It begins by confirming if the database is the bottleneck using `Stopwatch`, then details how to enable and inspect actual SQL queries generated by Entity Framework Core. The author explains how to reproduce and analyze queries using tools like SQL Server Management Studio and execution plans to pinpoint issues like missing indexes or table scans. Common solutions such as adding indexes, selecting only necessary columns, batching large queries, and avoiding N+1 problems are discussed. Finally, the article recommends using profilers and APM tools for live environment monitoring.]
---
```

# How I Analyze Slow Database Queries in My C# Projects | by Kittikawin L. üçÄ | Jul, 2025 | Medium

# How I Analyze Slow Database Queries in My C# Projects

![A person in a plaid shirt and baseball cap sits at a desk, looking at a computer monitor displaying code. A laptop, headphones, and a smartphone are also on the desk.](https://miro.medium.com/v2/resize:fit:700/0*J2K1YK94iygMwK4F)

Photo by [Per L√∂√∂v](https://unsplash.com/@perloov?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)

> _‚ÄúThe app is slow‚Äù ‚Äî The vaguest and scary feedback you will receive from users or QA. But most of the time, it ends up with a **database query**._

In this article, I will show you how I identify it.

In this article, I‚Äôll show you how I **identify, analyze, and fix slow queries** in my C# projects, from _Entity Framework Core_ to raw _SQL,_ using practical tools and proven techniques.

# Step 1: Confirm It‚Äôs the Database

Before you dive into SQL queries, ask:

*   Is it really the database?
*   Is the delay in the _API layer_, _serialization_, or _front-end_?

To validate, I start by **measuring the time it took to execute the database**, as follows:

```csharp
var stopwatch = Stopwatch.StartNew();  
var result = await _dbContext.Users.ToListAsync();  
stopwatch.Stop();  
  
_logger.LogInformation("Query took {Time} ms", stopwatch.ElapsedMilliseconds);
```

If the number is high ‚Üí it‚Äôs time to dive deeper.

[## Stopwatch Class (System.Diagnostics)
### Provides a set of methods and properties that you can use to accurately measure elapsed time.
learn.microsoft.com](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.stopwatch?view=net-9.0&redirectedfrom=MSDN&source=post_page-----80d50265bb96---------------------------------------)

# Step 2: Use Logging to Catch the Actual Query

If you‚Äôre using **Entity Framework Core**, enable SQL logging:

## ASP.NET Core (Program.cs):

```csharp
builder.Services.AddDbContext<AppDbContext>(options =>  
    options.UseSqlServer(configuration.GetConnectionString("DefaultConnection"))  
           .EnableSensitiveDataLogging()  
           .LogTo(Console.WriteLine, LogLevel.Information));
```

This logs the **actual SQL** EF is generating, often way more complex than you expect.

This log records the **actual SQL** EF that was created, which is often much more complex than you might expect.

Look for:

*   Missing `WHERE` clauses (aka `SELECT * FROM BigTable`)
*   [Cartesian Join or Cross Join](https://www.geeksforgeeks.org/sql/sql-cross-join/)
*   Filters are used in _memory_ instead of SQL.

[## Simple logging - EF Core
### Logging from an EF Core DbContext using LogTo
learn.microsoft.com](https://learn.microsoft.com/en-us/ef/core/logging-events-diagnostics/simple-logging?source=post_page-----80d50265bb96---------------------------------------#getting-detailed-messages)

# Step 3: Reproduce and Analyze the Query

Take the logged SQL and run it directly in:

*   [**SQL Server Management Studio (SSMS)**](https://learn.microsoft.com/en-us/ssms/)
*   [**Azure Data Studio**](https://azure.microsoft.com/en-us/products/data-studio)
*   [**pgAdmin**](https://www.pgadmin.org/) / [MySQL Workbench](https://www.mysql.com/products/workbench/), depending on your DB

Now use tools like:

*   [SET STATISTICS TIME ON](https://learn.microsoft.com/en-us/sql/t-sql/statements/set-statistics-time-transact-sql?view=sql-server-ver17)
*   [Execution Plans](https://learn.microsoft.com/th-th/sql/relational-databases/performance/display-an-actual-execution-plan?view=sql-server-ver16) (`Ctrl + M` in **SSMS**)
*   [EXPLAIN or EXPLAIN ANALYZE](https://www.postgresql.org/docs/current/sql-explain.html) (**PostgreSQL**)

These help identify:

*   Missing indexes
*   Table scans
*   Excessive reads or memory usage

# Step 4: Common solutions that work

This is what I usually do:

## 1. Add or restructure the index

If the execution plan shows a table scan or key lookup, you may need to:

*   A **non-clustered index** on `WHERE` columns
*   A **composite index,** if filtering by multiple columns

## 2. Select Only What You Need

```csharp
// Before -> get all users informations  
var users = await _dbContext.Users.ToListAsync();  
  
// After -> get only Id and Name  
var users = await _dbContext.Users  
    .Select(u => new { u.Id, u.Name })  // Project only needed fields  
    .ToListAsync();
```

This method greatly **reduces** the _load size_ and _memory usage_.

## 3. Batch or Paginate Large Queries

**Don‚Äôt pull 50,000 records into memory**. Use `.Skip()`, `.Take()` with a stream reader.

## 4. Avoid N+1 Query Problems

Use `Include()` or `ThenInclude()` properly:

```csharp
var orders = await _dbContext.Orders  
    .Include(o => o.Customer)  
    .Include(o => o.Items)  
    .ToListAsync();
```

For additional control: consider using `.Select()` projections or raw data joins.

# Bonus: Use a Profiler or APM Tool

Here are the tools I regularly use to **profile live or test environments**

*   [**MiniProfiler**](https://miniprofiler.com/): Lightweight, great for dev and staging
*   [**EFCore.BulkExtensions**](https://github.com/borisdj/EFCore.BulkExtensions): Helps bulk inserts/updates for heavy loads
*   [**Application Insights**](https://learn.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview) / [**New Relic**](https://newrelic.com/) / [**Dynatrace**](https://www.dynatrace.com/): Enterprise APM tools to see slow queries in real time
*   [**SQL Server Profiler**](https://learn.microsoft.com/en-us/sql/tools/sql-server-profiler/sql-server-profiler?view=sql-server-ver17) or [**Azure Query Performance Insight**](https://learn.microsoft.com/en-us/azure/azure-sql/database/query-performance-insight-use?view=azuresql)

# Example

In one project, an API call took **4 seconds**. I narrowed it down to one question:

```sql
SELECT * FROM Users WHERE Email = @email
```

It seems harmless, but the **Email column has no index**, and the table had **1M+ records.**

Adding a non-clustered index dropped the response time to **40ms**.

# Summary: My Slow Query Workflow

1.  Confirm that the database is the **bottleneck**
2.  **Log** and inspect the actual query
3.  Reproduce in a SQL client and view the execution plan
4.  Fix common issues: missing indexes, large selects, bad filters
5.  Use profiling tools to catch runtime issues
6.  Always test performance before shipping

# Final Thought

> _Most ‚Äúslow apps‚Äù are just_ **_apps with slow queries_**_._

Learning how to **diagnose** and **fix problems** will make you **10x** more valuable as a backend or full-stack developer.

See you,

**Kittikawin**