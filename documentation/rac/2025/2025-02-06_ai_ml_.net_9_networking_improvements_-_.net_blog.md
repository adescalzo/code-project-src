```yaml
---
title: .NET 9 Networking Improvements - .NET Blog
source: https://devblogs.microsoft.com/dotnet/dotnet-9-networking-improvements/?utm_source=newsletter.csharpdigest.net&utm_medium=newsletter&utm_campaign=asynchronous-programming&_bhlid=d601c0024103161908c20ea3a37f76fc981cd2f2
date_published: 2025-02-06T18:05:00.000Z
date_captured: 2025-08-17T22:04:20.370Z
domain: devblogs.microsoft.com
author: Máňa
category: ai_ml
technologies: [.NET 9, .NET, HTTP/3, HTTP/2, HTTP 1.1, QUIC, WebSockets, HttpClient, HttpClientFactory, SocketsHttpHandler, HttpClientHandler, ConcurrentStack, Dev Proxy, Fiddler, Roslyn Analyzers, MsQuic, OpenSSL, SChannel, Wireshark, Firefox, Chrome, cURL, Microsoft.Extensions.Http, Microsoft.Extensions.DependencyInjection, ASP.NET Core 9.0 Minimal APIs, OpenTelemetry .NET SDK, Azure Monitor Application Insights, .NET Aspire, NuGet, System.Net.ServerSentEvents]
programming_languages: [C#]
tags: [dotnet-9, networking, http, quic, websockets, httpclientfactory, security, diagnostics, performance, compatibility]
key_concepts: [connection-pooling, proxy-auto-update, distributed-tracing, keyed-dependency-injection, server-sent-events, tls-security, api-design, performance-optimization]
code_examples: false
difficulty_level: intermediate
summary: |
  This article details the significant networking improvements introduced in .NET 9, focusing on enhancements across HTTP, QUIC, and WebSockets. Key updates include performance optimizations for HTTP connection pooling and QUIC, the general availability of `System.Net.Quic` APIs, and new PING/PONG Keep-Alive strategies for WebSockets. The post also covers `HttpClientFactory` improvements like Keyed DI support and a change in the default primary handler, alongside crucial security features like SSLKEYLOGFILE support and improved TLS resume capabilities. Additionally, it highlights advancements in diagnostics, including URI query redaction in logs and enhanced distributed tracing with experimental connection tracing, and new networking primitives like a Server-Sent Events parser.
---
```

# .NET 9 Networking Improvements - .NET Blog

# .NET 9 Networking Improvements

Máňa, Natalia, Anton

## Table of contents

*   [HTTP](#http)
*   [Connection Pooling](#connection-pooling)
*   [Proxy Auto Update on Windows](#proxy-auto-update-on-windows)
*   [Community contributions](#community-contributions)
*   [QUIC](#quic)
*   [Public APIs](#public-apis)
*   [QUIC Connection Options](#quic-connection-options)
*   [Stream Capacity API](#stream-capacity-api)
*   [Performance Improvements](#performance-improvements)
*   [WebSockets](#websockets)
*   [.NET Framework Compatibility](#.net-framework-compatibility)
*   [Diagnostics](#diagnostics)
*   [Uri Query Redaction in HttpClientFactory Logs](#uri-query-redaction-in-httpclientfactory-logs)
*   [Distributed Tracing Improvements](#distributed-tracing-improvements)
*   [HttpClientFactory](#httpclientfactory)
*   [Keyed DI Support](#keyed-di-support)
*   [Default Primary Handler Change](#default-primary-handler-change)
*   [Security](#security)
*   [SSLKEYLOGFILE Support](#sslkeylogfile-support)
*   [TLS Resume with Client Certificate](#tls-resume-with-client-certificate)
*   [Negotiate API Integrity Checks](#negotiate-api-integrity-checks)
*   [Networking Primitives](#networking-primitives)
*   [Server-Sent Events Parser](#server-sent-events-parser)
*   [Primitives Additions](#primitives-additions)
*   [Final Notes](#final-notes)

Continuing our tradition, we are excited to share a blog post highlighting the latest and most interesting changes in the networking space with the new [.NET release](https://devblogs.microsoft.com/dotnet/announcing-dotnet-9/). This year, we are introducing updates in the [HTTP](#http) space, new [`HttpClientFactory`](#httpclientfactory) APIs, [.NET Framework compatibility](#net-framework-compatibility) improvements, and more.

## HTTP

In the following section, we’re introducing the most impactful changes in the HTTP space. Among which belong perf improvements in connection pooling, support for multiple HTTP/3 connections, auto-updating Windows proxy, and, last but not least, community contributions.

### Connection Pooling

In this release, we made two impactful performance improvements in HTTP connection pooling.

We added opt-in support for multiple HTTP/3 connections. Using more than one HTTP/3 connection to the peer is discouraged by the [RFC 9114](https://datatracker.ietf.org/doc/html/rfc9114#section-3.3) since the connection can multiplex parallel requests. However, in certain scenarios, like server-to-server, one connection might become a bottleneck even with request multiplexing. We saw such limitations with HTTP/2 ([dotnet/runtime#35088](https://github.com/dotnet/runtime/issues/35088)), which has the same concept of multiplexing over one connection. For the same reasons ([dotnet/runtime#51775](https://github.com/dotnet/runtime/issues/51775)), we decided to implement multiple connection support for HTTP/3 ([dotnet/runtime#101535](https://github.com/dotnet/runtime/issues/101535)).

The implementation itself tries to closely match the behavior of HTTP/2 multiple connections. Which, at the moment, always prefer to saturate existing connections with as many requests as allowed by the peer before opening a new one. Note that this is an implementation detail and the behavior might change in the future.

As a result, [our benchmarks](https://github.com/aspnet/Benchmarks/tree/main/src/BenchmarksApps/HttpClientBenchmarks) showed a nontrivial increase in requests per seconds (RPS), comparison for 10,000 parallel requests:

| client | single HTTP/3 connection | multiple HTTP/3 connections |
|---|---|---|
| Max CPU Usage (%) | 35 | 92 |
| Max Cores Usage (%) | 971 | 2,572 |
| Max Working Set (MB) | 3,810 | 6,491 |
| Max Private Memory (MB) | 4,415 | 7,228 |
| Processor Count | 28 | 28 |
| First request duration (ms) | 519 | 594 |
| Requests | 345,446 | 4,325,325 |
| Mean RPS | 23,069 | 288,664 |

Note that the increase in _Max CPU Usage_ implies better CPU utilization, which means that the CPU is busy processing requests instead of being idle.

This feature can be turned on via the `EnableMultipleHttp3Connections` property on [`SocketsHttpHandler`](https://learn.microsoft.com/dotnet/api/system.net.http.socketshttphandler.enablemultiplehttp3connections):

```csharp
var client = new HttpClient(new SocketsHttpHandler
{
    EnableMultipleHttp3Connections = true
});
```

We also addressed lock contention in HTTP 1.1 connection pooling ([dotnet/runtime#70098](https://github.com/dotnet/runtime/issues/70098)). The HTTP 1.1 connection pool previously used a single lock to manage the list of connections and the queue of pending requests. This lock was observed to be a bottleneck in high throughput scenarios on machines with a high number of CPU cores. We resolved this problem ([dotnet/runtime#99364](https://github.com/dotnet/runtime/pull/99364)) by replacing an ordinary list with a lock with a concurrent collection. We chose [`ConcurrentStack`](https://learn.microsoft.com/dotnet/api/system.collections.concurrent.concurrentstack-1) as it preserves the observable behavior when requests are handled by the newest available connection, which allows collecting older connections when their configured [lifetime](https://learn.microsoft.com/dotnet/api/system.net.http.socketshttphandler.pooledconnectionlifetime) expires. The throughput of HTTP 1.1 requests in our benchmarks increased by more than 30%:

| Client | .NET 8.0 | .NET 9.0 | Increase |
|---|---|---|---|
| Requests | 80,028,791 | 107,128,778 | +33.86% |
| Mean RPS | 666,886 | 892,749 | +33.87% |

### Proxy Auto Update on Windows

One of the main pain points when debugging HTTP traffic of applications using earlier versions of .NET is that the application doesn’t react to changes in Windows proxy settings ([dotnet/runtime#70098](https://github.com/dotnet/runtime/issues/46910)). The proxy settings were previously initialized once per process with no reasonable ability to refresh the settings. For example (with .NET 8), [`HttpClient.DefaultProxy`](https://learn.microsoft.com/dotnet/api/system.net.http.httpclient.defaultproxy) returns the same instance upon repeated access and never refetch the settings. As a result, tools like [Dev Proxy](https://learn.microsoft.com/microsoft-cloud/dev/dev-proxy/overview) or Fiddler, that set themselves as system proxy to listen for the traffic, weren’t able to capture traffic from already running processes. This issue was mitigated in [dotnet/runtime#103364](https://github.com/dotnet/runtime/pull/103364), where the `HttpClient.DefaultProxy` is set to an instance of Windows proxy that listens for registry changes and reloads the proxy settings when notified. The following code:

```csharp
while (true)
{
    using var resp = await client.GetAsync("https://httpbin.org/");
    Console.WriteLine(HttpClient.DefaultProxy.GetProxy(new Uri("https://httpbin.org/"))?.ToString() ?? "null");
    await Task.Delay(1_000);
}
```

produces output like this:

```text
null
// After Fiddler's "System Proxy" is turned on.
http://127.0.0.1:8866/
```

Note that this change applies only for Windows as it has a unique concept of [machine wide proxy settings](https://support.microsoft.com/windows/use-a-proxy-server-in-windows-03096c53-0554-4ffe-b6ab-8b1deee8dae1). Linux and other UNIX-based systems only allow setting up proxy via environment variables, which can’t be changed during process lifetime.

### Community contributions

We’d like to call out community contributions.

[`CancellationToken`](https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken) overloads were missing from [`HttpContent.LoadIntoBufferAsync`](https://learn.microsoft.com/dotnet/api/system.net.http.httpcontent.loadintobufferasync). This gap was resolved by an API proposal ([dotnet/runtime#102659](https://github.com/dotnet/runtime/issues/102659)) from [@andrewhickman-aveva](https://github.com/andrewhickman-aveva) and an implementation ([dotnet/runtime#103991](https://github.com/dotnet/runtime/pull/103991)) was from [@manandre](https://github.com/manandre).

Another change improves a units discrepancy for the `MaxResponseHeadersLength` property on [`SocketsHttpHandler`](https://learn.microsoft.com/dotnet/api/system.net.http.socketshttphandler) and [`HttpClientHandler`](https://learn.microsoft.com/dotnet/api/system.net.http.httpclienthandler) ([dotnet/runtime#75137](https://github.com/dotnet/runtime/issues/75137)). All the other size and length properties are interpreted as being in bytes, however this one is interpreted as being in kilobytes. And since the actual behavior can’t be changed due to backward compatibility, the problem was solved by implementing an analyzer ([dotnet/roslyn-analyzers#6796](https://github.com/dotnet/roslyn-analyzers/pull/6796)). The analyzer tries to make sure the user is aware that the value provided is interpreted as kilobytes, and warns if the usage suggests otherwise.

If the value is higher than a certain threshold, it looks like this:
![Analyzer Warning for MaxResponseHeadersLength](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/02/analyzer_warning.png "A screenshot of a Visual Studio-like IDE showing a C# code snippet with a MaxResponseHeadersLength property set to 64 * 1024. An analyzer warning is displayed above it, stating: 'Make sure the value '65536' is correct. This value is measured in kilobytes, not bytes. [blog-post-code] csharp(CA2262)'. This image illustrates a Roslyn analyzer warning about a unit discrepancy in a networking property.")

The analyzer was implemented by [@amiru3f](https://github.com/amiru3f).

## QUIC

The prominent changes in QUIC space in .NET 9 include making the library public, more configuration options for connections and several performance improvements.

### Public APIs

From this release on, `System.Net.Quic` isn’t hidden behind [`PreviewFeature`](https://learn.microsoft.com/dotnet/fundamentals/apicompat/preview-apis#requirespreviewfeaturesattribute) anymore and all the APIs are generally available without any opt-in switches ([dotnet/runtime#104227](https://github.com/dotnet/runtime/pull/104227)).

### QUIC Connection Options

We expanded the configuration options for [`QuicConnection`](https://learn.microsoft.com/dotnet/api/system.net.quic.quicconnection) ([dotnet/runtime#72984](https://github.com/dotnet/runtime/issues/72984)). The implementation ([dotnet/runtime#94211](https://github.com/dotnet/runtime/pull/94211)) added three new properties to [`QuicConnectionOptions`](https://learn.microsoft.com/dotnet/api/system.net.quic.quicconnectionoptions):

*   [`HandshakeTimeout`](https://learn.microsoft.com/dotnet/api/system.net.quic.quicconnectionoptions.handshaketimeout) – we were already imposing a limit on how long a connection establishment can take, this property just enables the user to adjust it.
*   [`KeepAliveInterval`](https://learn.microsoft.com/dotnet/api/system.net.quic.quicconnectionoptions.keepaliveinterval) – if this property is set up to a positive value, [PING frames](https://www.rfc-editor.org/rfc/rfc9000#name-ping-frames) are sent out regularly in this interval (in case no other activity is happening on the connection) which prevents the connection from being closed on [idle timeout](https://www.rfc-editor.org/rfc/rfc9000#name-idle-timeout).
*   [`InitialReceiveWindowSizes`](https://learn.microsoft.com/dotnet/api/system.net.quic.quicconnectionoptions.initialreceivewindowsizes) – a set of parameters to adjust the initial receive limits for data flow control sent in [transport parameters](https://www.rfc-editor.org/rfc/rfc9000#transport-parameter-definitions). These data limits apply only until the dynamic flow control algorithm starts adjusting the limits based on the data reading speed. And due to [MsQuic](https://github.com/microsoft/msquic/blob/main/docs/api/QUIC_SETTINGS.md) limitations, these parameters can only be set to values that are power of 2.

All of these parameters are optional. Their default values are derived from [MsQuic defaults](https://github.com/microsoft/msquic/blob/main/docs/Settings.md). The following code reports the defaults programmatically:

```csharp
var options = new QuicClientConnectionOptions();
Console.WriteLine($"KeepAliveInterval = {PrettyPrintTimeStamp(options.KeepAliveInterval)}");
Console.WriteLine($"HandshakeTimeout = {PrettyPrintTimeStamp(options.HandshakeTimeout)}");
Console.WriteLine(@$"InitialReceiveWindowSizes =
{{
    Connection = {PrettyPrintInt(options.InitialReceiveWindowSizes.Connection)},
    LocallyInitiatedBidirectionalStream = {PrettyPrintInt(options.InitialReceiveWindowSizes.LocallyInitiatedBidirectionalStream)},
    RemotelyInitiatedBidirectionalStream = {PrettyPrintInt(options.InitialReceiveWindowSizes.RemotelyInitiatedBidirectionalStream)},
    UnidirectionalStream = {PrettyPrintInt(options.InitialReceiveWindowSizes.UnidirectionalStream)}
}}");

static string PrettyPrintTimeStamp(TimeSpan timeSpan)
    => timeSpan == Timeout.InfiniteTimeSpan ? "infinite" : timeSpan.ToString();

static string PrettyPrintInt(int sizeB)
    => sizeB % 1024 == 0 ? $"{sizeB / 1024} * 1024" : sizeB.ToString();

// Prints:
// KeepAliveInterval = infinite
// HandshakeTimeout = 00:00:10
// InitialReceiveWindowSizes =
// {
//     Connection = 16384 * 1024,
//     LocallyInitiatedBidirectionalStream = 64 * 1024,
//     RemotelyInitiatedBidirectionalStream = 64 * 1024,
//     UnidirectionalStream = 64 * 1024
// }
```

### Stream Capacity API

.NET 9 also introduced new APIs to support [multiple HTTP/3 connections](#connection-pooling) in [`SocketsHttpHandler`](https://learn.microsoft.com/dotnet/api/system.net.http.socketshttphandler.enablemultiplehttp3connections) ([dotnet/runtime#101534](https://github.com/dotnet/runtime/issues/101534)). The APIs were designed with this specific usage in mind, and we don’t expect them to be used apart from very niche scenarios.

QUIC has built-in logic for managing [stream limits](https://www.rfc-editor.org/rfc/rfc9000#name-max_streams-frames) within the protocol. As a result, calling [`OpenOutboundStreamAsync`](https://learn.microsoft.com/dotnet/api/system.net.quic.quicconnection.openoutboundstreamasync) on a connection gets suspended if there isn’t any available stream capacity. Moreover, there isn’t an efficient way to learn whether the stream limit was reached or not. All these limitations together didn’t allow the HTTP/3 layer to know when to open a new connection. So we introduced a new [`StreamCapacityCallback`](https://learn.microsoft.com/dotnet/api/system.net.quic.quicconnectionoptions.streamcapacitycallback) that gets called whenever stream capacity is increased. The callback itself is registered via [`QuicConnectionOptions`](https://learn.microsoft.com/dotnet/api/system.net.quic.quicconnectionoptions). More details about the callback can be found in the [documentation](https://learn.microsoft.com/dotnet/fundamentals/networking/quic/quic-options#streamcapacitycallback).

### Performance Improvements

Both performance improvements in `System.Net.Quic` are TLS related and both only affect connection establishing times.

The first performance related change was to run the peer certificate validation asynchronously in .NET thread pool ([dotnet/runtime#98361](https://github.com/dotnet/runtime/pull/98361)). The certificate validation can be time consuming on its own and it might even include an execution of a user callback. Moving this logic to .NET thread pool stops us blocking the MsQuic thread, of which MsQuic has a limited number, and thus enables MsQuic to process higher number of new connections at the same time.

On top of that, we have introduced caching of MsQuic configuration ([dotnet/runtime#99371](https://github.com/dotnet/runtime/pull/99371)). MsQuic configuration is a set of native structures containing connection settings from [`QuicConnectionOptions`](https://learn.microsoft.com/dotnet/api/system.net.quic.quicconnectionoptions), potentially including certificate and its intermediaries. Constructing and initializing the native structure might be very expensive since it might require serializing and deserializing all the certificate data to and from [PKS #12](https://datatracker.ietf.org/doc/html/rfc7292) format. Moreover, the cache allows reusing the same MsQuic configuration for different connections if their settings are identical. Specifically server scenarios with static configuration can notably profit from the caching, like the following code:

```csharp
var alpn = "test";
var serverCertificate = X509CertificateLoader.LoadCertificateFromFile("../path/to/cert");

// Prepare the connection option upfront and reuse them.
var serverConnectionOptions = new QuicServerConnectionOptions()
{
    DefaultStreamErrorCode = 123,
    DefaultCloseErrorCode = 456,
    ServerAuthenticationOptions = new SslServerAuthenticationOptions
    {
        ApplicationProtocols = new List<SslApplicationProtocol>() { alpn },
        // Re-using the same certificate.
        ServerCertificate = serverCertificate
    }
};

// Configure the listener to return the pre-prepared options.
await using var listener = await QuicListener.ListenAsync(new QuicListenerOptions()
{
    ListenEndPoint = new IPEndPoint(IPAddress.Loopback, 0),
    ApplicationProtocols = [ alpn ],
    // Callback returns the same object.
    // Internal cache will re-use the same native structure for every incoming connection.
    ConnectionOptionsCallback = (_, _, _) => ValueTask.FromResult(serverConnectionOptions)
});
```

We also built it an escape hatch for this feature, it can be turned off with either environment variable:

```sh
export DOTNET_SYSTEM_NET_QUIC_DISABLE_CONFIGURATION_CACHE=1
# run the app
```

or with an [AppContext](https://learn.microsoft.com/dotnet/api/system.appcontext) switch:

```csharp
AppContext.SetSwitch("System.Net.Quic.DisableConfigurationCache", true);
```

## WebSockets

.NET 9 introduces the long-desired PING/PONG Keep-Alive strategy to WebSockets ([dotnet/runtime#48729](https://github.com/dotnet/runtime/issues/48729)).

Prior to .NET 9, the only available Keep-Alive strategy was Unsolicited PONG. It was enough to keep the underlying TCP connection from idling out, but in a case when a remote host becomes unresponsive (for example, a remote server crashes), the only way to detect such situations was to depend on the TCP timeout.

In this release, we complement the existing `KeepAliveInterval` setting with the new `KeepAliveTimeout` setting, so that the Keep-Alive strategy is selected as follows:

1.  Keep-Alive is **OFF**, if
    *   `KeepAliveInterval` is `TimeSpan.Zero` or `Timeout.InfiniteTimeSpan`
2.  **Unsolicited PONG**, if
    *   `KeepAliveInterval` is a positive finite `TimeSpan`, -AND-
    *   `KeepAliveTimeout` is `TimeSpan.Zero` or `Timeout.InfiniteTimeSpan`
3.  **PING/PONG**, if
    *   `KeepAliveInterval` is a positive finite `TimeSpan`, -AND-
    *   `KeepAliveTimeout` is a positive finite `TimeSpan`

By default, the preexisting Keep-Alive behavior is maintained: `KeepAliveTimeout` default value is `Timeout.InfiniteTimeSpan`, so Unsolicited PONG remains as the default strategy.

The following example illustrates how to enable the PING/PONG strategy for a `ClientWebSocket`:

```csharp
var cws = new ClientWebSocket();