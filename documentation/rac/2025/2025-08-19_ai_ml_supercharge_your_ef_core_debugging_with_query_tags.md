```yaml
---
title: Supercharge your EF Core debugging with Query Tags
source: https://bartwullems.blogspot.com/2025/08/supercharge-your-ef-core-debugging-with.html?utm_source=bonobopress&utm_medium=newsletter&utm_campaign=2112
date_published: 2025-08-19T05:23:00.000Z
date_captured: 2025-08-25T10:14:09.497Z
domain: bartwullems.blogspot.com
author: Visit profile
category: ai_ml
technologies: [EF Core, Entity Framework Core, .NET Core, GitHub, OpenTelemetry]
programming_languages: [C#, SQL, LINQ]
tags: [ef-core, debugging, sql, data-access, dotnet, query-tags, performance, tracing, linq, observability]
key_concepts: [query-tagging, sql-debugging, linq-to-sql, observability, correlation-id, query-optimization, database-profiling]
code_examples: false
difficulty_level: intermediate
summary: |
  [This article introduces EF Core Query Tags as an elegant solution for debugging database queries. When an application generates numerous SQL statements, Query Tags allow developers to embed custom comments directly into the generated SQL, making it easy to trace a SQL query back to its originating LINQ expression. The post demonstrates basic usage with the `TagWith` method, advanced techniques like chaining multiple tags, and dynamic tags incorporating runtime information such as a correlation ID for end-to-end traceability. While the performance impact is minimal, the author advises against excessively long or complex dynamic tags in performance-critical paths. This feature significantly simplifies the process of identifying and understanding specific queries within a complex application.]
---
```

# Supercharge your EF Core debugging with Query Tags

### Supercharge your EF Core debugging with Query Tags

Debugging database queries in Entity Framework Core can sometimes feel like searching for a needle in a haystack. When your application generates dozens or hundreds of SQL queries, identifying which LINQ query produced which SQL statement becomes a real challenge.

Fortunately, I discovered an elegant solution that EF Core provides: Query Tags.

# Query Tags

Query Tags allow you to add custom comments to the SQL queries generated by your LINQ expressions. These comments appear directly in the generated SQL, making it incredibly easy to trace back from a SQL query to the specific code that created it.

To use this feature you need to apply the `TagWith` method to your on any `IQueryable` and pass a descriptive comment:

```csharp
var expensiveOrders = context.Orders
    .TagWith("Finding orders over $1000 for quarterly report")
    .Where(o => o.Total > 1000)
    .Include(o => o.Customer)
    .ToList();
```

This generates SQL that looks like this:

```sql
-- Finding orders over $1000 for quarterly report
SELECT [o].[Id], [o].[CustomerId], [o].[Total], [c].[Id], [c].[Name]
FROM [Orders] AS [o]
INNER JOIN [Customers] AS [c] ON [o].[CustomerId] = [c].[Id]
WHERE [o].[Total] > 1000.0
```

Instead of trying to reverse-engineer which code generated a particular SQL query, you can immediately see the purpose and origin of each query in your database logs or profiler.

# Advanced techniques

#### Chaining multiple tags

You can chain multiple `TagWith` calls to add additional context:

```csharp
var userOrders = context.Orders
    .TagWith("User dashboard query")
    .TagWith($"User ID: {userId}")
    .TagWith("Performance critical - cache results")
    .Where(o => o.CustomerId == userId)
    .OrderByDescending(o => o.OrderDate)
    .Take(10)
    .ToList();
```

This produces:

```sql
-- User dashboard query
-- User ID: 12345
-- Performance critical - cache results
SELECT TOP(10) [o].[Id], [o].[CustomerId], [o].[OrderDate]
FROM [Orders] AS [o]
WHERE [o].[CustomerId] = 12345
ORDER BY [o].[OrderDate] DESC
```

**Remark:** While the performance impact of `TagWith` is minimal, avoid excessively long tags or complex string interpolation in hot paths.

#### Dynamic tags with context

You can create dynamic tags that include runtime information:

```csharp
public async Task<List<Product>> GetProductsByCategoryAsync(int categoryId, string correlationId)
{
    return await context.Products
        .TagWith($"GetProductsByCategory - CategoryId: {categoryId}, CorrelationId: {correlationId}")
        .Where(p => p.CategoryId == categoryId)
        .ToListAsync();
}
```

**Remark:** I like to use this to pass the OpenTelemetry correlation id as you can see in the example above. This helps to give end-to-end traceability.