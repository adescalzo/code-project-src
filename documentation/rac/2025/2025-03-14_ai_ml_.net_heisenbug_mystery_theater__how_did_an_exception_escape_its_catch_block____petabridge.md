```yaml
---
title: ".NET Heisenbug Mystery Theater: How Did an Exception Escape its Catch Block? | Petabridge"
source: https://petabridge.com/blog/dotnet-heisenbug-mystery-theater-catch-block/?utm_source=bonobopress&utm_medium=newsletter&utm_campaign=2024
date_published: 2025-03-14T17:41:11.000Z
date_captured: 2025-08-19T11:25:21.595Z
domain: petabridge.com
author: Unknown
category: ai_ml
technologies: [Akka.NET, Akka.Streams, Akka.Streams.Kafka, Akka.Persistence.Sql, .NET, OpenTelemetry, Phobos, Petabridge.Cmd]
programming_languages: [C#]
tags: [akka.net, distributed-systems, concurrency, asynchronous-programming, heisenbug, structs, .net, error-handling, performance, debugging]
key_concepts: [Heisenbug, Atomicity, Struct Tearing, Asynchronous Programming, Task Continuations, Akka.Streams, Actor Model, Concurrency Issues]
code_examples: false
difficulty_level: intermediate
summary: |
  [This article details the investigation and resolution of a "Heisenbug" in Akka.NET's `SelectAsync` stream stage, where an exception appeared to bypass its `catch` block. The core issue was identified as "struct tearing," a non-atomic assignment problem with user-defined `structs` (`Result<T>`) when accessed concurrently by different threads. This led to a partially written `struct` being read, resulting in a `null` exception being propagated downstream and causing an `ArgumentException`. The solution involved refactoring the code to ensure the `struct` assignment and subsequent read occurred within the same thread-safe `AsyncCallback`. The post serves as a cautionary tale about low-level concurrency pitfalls in .NET and advocates for simplification in design to prevent such complex bugs.]
---
```

# .NET Heisenbug Mystery Theater: How Did an Exception Escape its Catch Block? | Petabridge

# .NET Heisenbug Mystery Theater: How Did an Exception Escape its Catch Block?

### A painful lesson on atomicity and the assignment of structs.

21 minutes to read

*   [`SelectAsync` Exceptions](#selectasync-exceptions)
*   [The Plumbing](#the-plumbing)
*   [`Task`s, “Atomic” `struct` Assignments, and Lies](#tasks-atomic-struct-assignments-and-lies)
*   [Fixing the Heisenbug](#fixing-the-heisenbug)

Over the past several months the Akka.NET team has had reports of the following `Exception` popping up unexpectedly throughout many of our plugins and end-user applications that use the Akka.Streams `SelectAsync` stage - such as [Akka.Streams.Kafka](https://github.com/akkadotnet/Akka.Streams.Kafka) and [Akka.Persistence.Sql](https://github.com/akkadotnet/Akka.Persistence.Sql):

![Screenshot of an error log showing an `ArgumentException` with the message 'Cancellation cause must not be null', indicating an issue during Akka.NET stream cancellation.](images/2025/heisenbug-mystery/argument-exception.png)

That error message seems simple enough - it comes from here [inside `GraphStage.cs`](https://github.com/akkadotnet/akka.net/blob/848a7b20fa31a7f733e4d75f40f0bc4bf8ffc0fc/src/core/Akka.Streams/Stage/GraphStage.cs):

```csharp
[InternalApi] 
public void InternalOnDownstreamFinish(Exception cause)
{
    try
    {
        if (cause == null)
            throw new ArgumentException("Cancellation cause must not be null", nameof(cause));
```

In Akka.Streams parlance, a stream gets cancelled when an unhandled `Exception` is thrown and that error _should_ be propagated all the way down to this `GraphStage.InternalOnDownstreamFinish` method so we can log why the stream is being cancelled / terminated.

Here’s the mystery - _this_ is the code that “threw” the `Exception` inside Akka.Persistence.Sql for instance:

```csharp
.SelectAsync(
    JournalConfig.DaoConfig.Parallelism,
    async promisesAndRows =>
    {
        try
        {
            await WriteJournalRows(promisesAndRows.Rows);
            foreach (var taskCompletionSource in promisesAndRows.Tcs)
                taskCompletionSource.TrySetResult(NotUsed.Instance);
        }
        catch (Exception e)
        {
            foreach (var taskCompletionSource in promisesAndRows.Tcs)
                taskCompletionSource.TrySetException(e);
        }

        return NotUsed.Instance;
    })
```

How on Earth did the `Exception` escape the `catch` block? And why do we have _no record_ of it by the time the stream completes? That is the mystery we are going to explore today.

## `SelectAsync` Exceptions

Over several months we attempted to trap this issue so we could accurately locate where it was happening inside our code. The original `ArgumentException` was very broad, so we needed better data:

*   [https://github.com/akkadotnet/akka.net/pull/7433](https://github.com/akkadotnet/akka.net/pull/7433)
*   [https://github.com/akkadotnet/akka.net/pull/7497](https://github.com/akkadotnet/akka.net/pull/7497)

And eventually, those changes produced logs that looked like this:

```
[ERROR][03/14/2025 06:26:33.434Z][Thread 0029][FlowShape`2([SelectAsync.in] [SelectAsync.out])(akka://KafkaUnexpectedRecordsConsumer2/user/kafka-unexpected-records-100-no-PollKafka-actor/worker-0/StreamSupervisor-2)] An exception occured inside SelectAsync while processing message [Akka.Streams.Kafka.Messages.CommittableMessage`2[Confluent.Kafka.Ignore,System.Byte[]]]. Supervision strategy: Stop
```

And different users using different plugins, both of which use `SelectAsync` internally, reported similar versions of this new error too:

*   [Kafka Producer - Exception occured inside SelectAsync - Cancellation cause must not be null](https://github.com/akkadotnet/Akka.Streams.Kafka/issues/426)
*   [`BaseByteArrayJournalDao` lacks resiliency against stream failure](https://github.com/akkadotnet/Akka.Persistence.Sql/issues/497)

Ok, so now we know where the `Exception` is coming from - `SelectAsync`. That narrows our search area by a significant amount. Now the next question is - how can an `Exception` escape this code inside `SelectAsync`?

![Screenshot of a C# code snippet demonstrating a `SelectAsync` block protected by a `try-catch` statement, intended to handle exceptions within an asynchronous operation.](images/2025/heisenbug-mystery/select-async-catch.png)

## The Plumbing

If we peel the covers back on `SelectAsync` we have the following:

```csharp
public SelectAsync(int parallelism, Func<TIn, Task<TOut>> mapFunc)
{
    _parallelism = parallelism;
    _mapFunc = mapFunc;
    Shape = new FlowShape<TIn, TOut>(In, Out);
}
```

Akka.Streams’ syntax looks a lot like LINQ, but the differences are:

1.  It’s asynchronous, all run by Akka.NET actors under the covers and
2.  It’s back-pressure aware - if a stage is blocking as a result of an I/O or compute constraint, we block the upstream stages from emitting new events.

The `int parallelism` is one of the tools that `SelectAsync` uses to create backpressure - by limiting the number of in-flight tasks that can be executing at any given time. The `mapFunc` is what emits the `Task<TOut>` that we are going to `await` on.

The other thing that is special about `SelectAsync` is that it _preserves invocation order_ - even if the parallel `Task<TOut>`s complete in arbitrary orders (which they almost certainly will), we will always deliver the results of `SelectAsync` in the original invocation order of the `TIn` inputs sent to us.

Therefore, `SelectAsync` has to have a data structure for storing the pending `Task<TOut>`’s _eventual_ output for this purpose:

```csharp
private class Holder<T>
{
    private readonly Action<Holder<T>> _callback;

    public Holder(object message, Result<T> element, Action<Holder<T>> callback)
    {
        _callback = callback;
        Message = message;
        Element = element;
    }

    public Result<T> Element { get; private set; }
    public object Message { get; }

    public void SetElement(Result<T> result)
    {
        Element = result.IsSuccess && result.Value == null
            ? Result.Failure<T>(ReactiveStreamsCompliance.ElementMustNotBeNullException)
            : result;
    }

    public void Invoke(Result<T> result)
    {
        SetElement(result);
        _callback(this);
    }
}
```

That’s what the `Holder<T>` does, and the `Holder<T>` will eventually accept a `Result<T>` once the `Task<T>` completes:

```csharp
public struct Result<T> : IEquatable<Result<T>>
{
    public readonly bool IsSuccess;

    public readonly T Value;

    public readonly Exception Exception;

    public Result(T value) : this()
    {
        IsSuccess = true;
        Value = value;
    }

    public Result(Exception exception) : this()
    {
        IsSuccess = false;
        Exception = exception;
    }
}
```

And this is where all of the magic happens inside `SelectAsync`:

```csharp
public override void OnPush()
{
    var message = Grab(_stage.In);
    try
    {
        var task = _stage._mapFunc(message);
        var holder = new Holder<TOut>(message, NotYetThere, _taskCallback);
        _buffer.Enqueue(holder);

        // We dispatch the task if it's ready to optimize away
        // scheduling it to an execution context
        if (task.IsCompleted)
        {
            holder.SetElement(Result.FromTask(task));
            HolderCompleted(holder);
        }
        else
            task.ContinueWith(t => holder.Invoke(Result.FromTask(t)),
                TaskContinuationOptions.ExecuteSynchronously);
    }
    catch (Exception e)
    {
    	// ... error handling
    }
```

1.  Once we get a new `TIn` “pushed” to use from upstream, we will invoke the user-defined function and receive a new `Task<TOut>`;
2.  We will check to see if this `Task` completed quickly and if it has, we will immediately call `Holder<TOut>.SetElement` without using a continuation `Task`; and
3.  If the `Task` is still running, we will schedule a continuation `Task` and have _that_ call `Holder<TOut>.Invoke`.

`Holder<T>.Invoke` ended up being the key detail in this whole piece - remember, these `Task`s that `SelectAsync` is produced are being run as detached `Task`s. So when they complete, we’re relying on a little bit of Akka.Streams infrastructure to marshall the results back into our actors in a thread-safe way:

```csharp
Action<Holder<T>> _taskCallback = GetAsyncCallback<Holder<TOut>>(HolderCompleted);

private void HolderCompleted(Holder<TOut> holder)
{
    var element = holder.Element;
    if (element.IsSuccess)
    {
        if (IsAvailable(_stage.Out))
            PushOne();
        return;
    }
    
    var exception = element.Exception;
    var strategy = _decider(exception);
    Log.Error(exception, "An exception occured inside SelectAsync while executing Task. Supervision strategy: {0}", strategy);
    switch (strategy)
    {
        case Directive.Stop:
            FailStage(exception); // THIS IS WHERE THE PROBLEMS OCCURRED
            break;
        
        case Directive.Resume:
        case Directive.Restart:
            if (IsAvailable(_stage.Out))
                PushOne();
            break;
        
        default:
            throw new AggregateException($"Unknown SupervisionStrategy directive: {strategy}", exception);
    }
}
```

The `GetAsyncCallback` method decorates our `Action<TOut>` to transform it into an [actor message, which gets processed normally inside the Akka.Streams’ actors thread-safe context](../how-akkadotnet-actors-process-messages/). This is necessary in order to make sure that the callback function can safely access the Akka.Stream state without needing `lock`s or any synchronization mechanisms.

That callback function is where the exception was getting detected - but here’s the catch: **the `Exception` was `null` here**. This is what created our original `ArgumentException` error at the start of the post. But how could this occur?

## `Task`s, “Atomic” `struct` Assignments, and Lies

There are two critical details at work here:

1.  There is something very fishy about the `Holder<T>.Invoke` method.
2.  `Result<T>` is a user-defined `struct`.

First, let’s take a look at `Holder<T>.Invoke` with some extra comments:

```csharp
public void Invoke(Result<T> result)
{
    SetElement(result); // happens inside the `ContinueWith` function's context
    _callback(this); // happens inside the SelectAsync `StageActor` context
    // VERY, VERY LIKELY THAT THESE ARE TWO DIFFERENT THREADS
}
```

This call is actually split across two different threads of execution - as my comments highlight. This is a potentially unsafe assignment. A no-no.

```csharp
private static readonly Result<TOut> NotYetThere = Result.Failure<TOut>(new Exception());

var holder = new Holder<TOut>(message, NotYetThere, _taskCallback);
```

When we create a brand new `Holder<TOut>` we initialize its result with a placeholder `NotYetThere` value, which we will check for whenever the `SelectAsync` stage gets pulled for output by the stages below it:

```csharp
else if (_buffer.Peek().Element == NotYetThere)
{
    if (Todo < _stage._parallelism && !HasBeenPulled(inlet))
        TryPull(inlet);
}
else
{
    var holder = _buffer.Dequeue();
    var result = holder.Element;
    if (!result.IsSuccess)
    {
        // this could happen if we are looping in PushOne and end up on a failed Task before the
        // HolderCompleted callback has run
        var strategy = _decider(result.Exception);
        Log.Error(result.Exception, "An exception occured inside SelectAsync while processing message [{0}]. Supervision strategy: {1}", holder.Message, strategy);
        switch (strategy)
        {
            case Directive.Stop:
            // `Exception` is null and gets passed all the way down to InternalOnDownstreamFinish, which blows up
                FailStage(result.Exception);
```

The reason I point this out: we can’t pull an element where `Holder<TOut>.Result` has not been assigned yet - the `NotYetThere` check ensures this.

HOWEVER: `struct` assignment does not work the same way `class` or “heap” assignment does.

Here’s the rub: remember how I said `Result<T>` is a `struct`? Well when you assign a user-defined `struct` _that operation is not atomic_! In the [words of the great Eric Lippert](https://ericlippert.com/2011/05/31/atomicity-volatility-and-immutability-are-different-part-two/):

> I also talked a bit about how making fields of a struct readonly has no effect on atomicity; when the struct is copied around, it may be copied around four bytes at a time regardless of whether its fields are marked as readonly or not.
> 
> There is a larger problem though with reasoning about readonly fields in a struct beyond their non-atomicity. Yes, when you read from readonly fields in a struct on multiple threads without any locking, you can get inconsistent results due to race conditions. But the situation is actually worse than that; readonly fields need not give you results that you think are consistent even on one thread! Basically, readonly fields in a struct are the moral equivalent of the struct author writing a cheque without having the funds to back it.

So here’s how we ended up with a `null` Exception that escaped the `catch` block - the `default` value of a `Result<T>` looks like this:

```csharp
public struct Result<T> : IEquatable<Result<T>>
{
    public readonly bool IsSuccess; // false
 
    public readonly T Value; // null

    public readonly Exception Exception; // null

    public Result()
    {
    }
}
```

In some instances while the `Result<T>` value was being assigned on one thread, it was being dirtily / unsafely read on another as its `default(Result<T>)` value - which gives us a `null` `Exception` with `IsSuccess == false`. That set of conditions would transport us _exactly_ to this error state here:

```csharp
if (!result.IsSuccess) // we pass here because `IsSuccess == false`
    {
        var strategy = _decider(result.Exception); // decider does not care if Exception is `null`
        Log.Error(result.Exception, "An exception occured inside SelectAsync while processing message [{0}]. Supervision strategy: {1}", holder.Message, strategy);
        switch (strategy)
        {
            case Directive.Stop:
            // `Exception` is null and gets passed all the way down to InternalOnDownstreamFinish, which blows up
                FailStage(result.Exception);
```

Here’s the rub: this “exception” can AND DID occur without a real `Exception` ever being thrown inside `SelectAsync` the entire time. It was entirely the dirty assignment + read of the `Result<T>` `struct` that created this problem.

## Fixing the Heisenbug

This bug was a true [Heisenbug](https://en.wikipedia.org/wiki/Heisenbug) in the sense that it was elusive to observe via traditional debugging. The debugger created just enough lag where the two threads could both read the same assigned value for the `struct Result<T>`.

However, [fixing it was quite simple](https://github.com/akkadotnet/akka.net/pull/7521): just do everything inside the `AsyncCallback`:

```csharp
private sealed class Holder<T>(object? message, Result<T> element)
{
    public object? Message { get; private set; } = message;
    
    public Result<T> Element { get; private set; } = element;

    public void SetElement(Result<T> result)
    {
        Element = result.IsSuccess && result.Value == null
            ? Result.Failure<T>(ReactiveStreamsCompliance.ElementMustNotBeNullException)
            : result;
    }
}

private readonly Action<(Holder<TOut>, Result<TOut>)> _taskCallback;

_taskCallback = GetAsyncCallback<(Holder<TOut> holder, Result<TOut> result)>
	(t => HolderCompleted(t.holder, t.result));

private void HolderCompleted(Holder<TOut> holder, Result<TOut> result)
{
    // we may not be at the front of the line right now, so save the result for later
    holder.SetElement(result);
    if (result.IsSuccess)
    {
        if (IsAvailable(_stage.Out))
            PushOne();
        return;
    }

    // rest of method
}
```

If your first impulse upon seeing an issue like this is to build some sort of Rube-Goldberg machine out of synchronization code: **stop**!

In many cases these types of problems can be solved via simplification - in this instance, moving the assignment and reading of the `struct` and to inside the same thread.

If you liked this post, you can [share it with your followers](https://twitter.com/intent/tweet?url=https://petabridge.com/blog/dotnet-heisenbug-mystery-theater-catch-block/&text=.NET+Heisenbug+Mystery+Theater%3A+How+Did+an+Exception+Escape+its+Catch+Block%3F&via=petabridge) or [follow us on Twitter](https://twitter.com/petabridge)!

Written by [Aaron Stannard](http://twitter.com/Aaronontheweb) on March 14, 2025

*   Read more about:
*   [Akka.NET](/blog/category/akkadotnet/)
*   [Case Studies](/blog/category/case-studies/)
*   [Videos](/blog/category/videos/)