```yaml
---
title: "How to use IHttpClientFactory and WireMock.NET together using Moq | Code4IT"
source: https://www.code4it.dev/blog/wiremock-ihttpclientfactory-moq/?utm_source=newsletter.csharpdigest.net&utm_medium=newsletter&utm_campaign=10-lessons-i-learned-from-using-aspire-in-production&_bhlid=a6b48b65de161d42031dea0809b99cd50f481240
date_published: 2024-10-01T00:00:00.000Z
date_captured: 2025-08-08T15:49:08.931Z
domain: www.code4it.dev
author: Davide Bellone
category: ai_ml
technologies: [WireMock.NET, Moq, IHttpClientFactory, HttpClient, .NET, NuGet, xUnit, FluentAssertions, .NET Aspire, NSubstitute]
programming_languages: [C#]
tags: [wiremock.net, httpclientfactory, moq, unit-testing, mocking, integration-testing, dotnet, csharp, web-api, http-client]
key_concepts: [http-client-mocking, in-memory-server, dependency-injection, unit-testing, mocking-frameworks, socket-exhaustion, test-doubles, httpclientfactory-pattern]
code_examples: false
difficulty_level: intermediate
summary: |
  This article provides a practical guide on integrating WireMock.NET with `IHttpClientFactory` and Moq for effective HTTP client testing in .NET applications. It addresses the challenge of mocking `HttpClient` instances generated by `IHttpClientFactory` to simulate external API interactions. The author demonstrates how to configure WireMock.NET as an in-memory server to define mock responses and then use Moq to inject a `HttpClient` instance, pre-configured with WireMock.NET's base URL, into a service under test. The post includes C# code examples and highlights the advantages of this approach for robust and isolated unit and integration testing.
---
```

# How to use IHttpClientFactory and WireMock.NET together using Moq | Code4IT

# How to use IHttpClientFactory and WireMock.NET together using Moq

> WireMock.NET is a popular library used to simulate network communication through HTTP. But there is no simple way to integrate the generated in-memory server with an instance of IHttpClientFactory injected via constructor. Right? Wrong!

## Table of Contents

*   [Explaining the dummy class used for the examples](#explaining-the-dummy-class-used-for-the-examples)
*   [WireMock.NET, a library to simulate HTTP calls](#wiremocknet-a-library-to-simulate-http-calls)
*   [Basic configuration of HTTP requests and responses with WireMock.NET](#basic-configuration-of-http-requests-and-responses-with-wiremocknet)
*   [How to integrate WireMock.NET with a Moq-driven IHttpClientFactory](#how-to-integrate-wiremocknet-with-a-moq-driven-ihttpclientfactory)
*   [Let WireMock.NET create the HttpClient for you](#let-wiremocknet-create-the-httpclient-for-you)
*   [Further readings](#further-readings)
*   [Wrapping up](#wrapping-up)

Testing the integration with external HTTP clients can be a cumbersome task, but most of the time, it is necessary to ensure that a method is able to perform correct operations - not only sending the right information but also ensuring that we are able to read the content returned from the called API.

Instead of spinning up a real server (even if in the local environment), we can simulate a connection to a mock server. A good library for creating temporary in-memory servers is WireMock.NET.

Many articles I read online focus on creating a simple `HttpClient`, using WireMock.NET to drive its behaviour. In this article, we are going to do a little step further: we are going to use WireMock.NET to handle `HttpClient`s generated, using Moq, via `IHttpClientFactory`.

## Explaining the dummy class used for the examples

As per every practical article, we must start with a dummy example.

For the sake of this article, I‚Äôve created a dummy class with a single method that calls an external API to retrieve details of a book and then reads the returned content. If the call is successful, the method returns an instance of `Book`; otherwise, it throws a `BookServiceException` exception.

Just for completeness, here‚Äôs the `Book` class:

```cs
public class Book
{
    public int Id { get; set; }
    public string Title { get; set; }
}
```

And here‚Äôs the `BookServiceException` definition:

```cs
[Serializable]
public class BookServiceException: Exception
{
    public BookServiceException(string message, Exception inner) : base(message, inner) { }
    protected BookServiceException(
      System.Runtime.Serialization.SerializationInfo info,
      System.Runtime.Serialization.StreamingContext context) : base(info, context) { }
}
```

Finally, we have our main class:

```cs
public class BookService
{
    private readonly IHttpClientFactory _httpClientFactory;

    public BookService(IHttpClientFactory httpClientFactory)
    {
        _httpClientFactory = httpClientFactory;
    }

    public async Task<Book> GetBookById(int id)
    {

        string url = $"/api/books/{id}";
        HttpClient httpClient = _httpClientFactory.CreateClient("books_client");

        try
        {
                Book? book = await httpClient.GetFromJsonAsync<Book>(url);
                return book;
        }
        catch (Exception ex)
        {
                throw new BookServiceException($"There was an error while getting info about the book {id}", ex);
        }
    }
}
```

There are just two things to notice:

*   We are injecting an instance of `IHttpClientFactory` into the constructor.
*   We are generating an instance of `HttpClient` by **passing a name to the `CreateClient` method of `IHttpClientFactory`**.

Now that we have our cards on the table, we can start!

## WireMock.NET, a library to simulate HTTP calls

[WireMock](https://wiremock.org/) is an open-source platform you can install locally to create a real mock server. You can even create a cloud environment to generate and test HTTP endpoints.

However, for this article we are interested in the **NuGet package that takes inspiration from the WireMock project**, allowing .NET developers to generate disposable in-memory servers: `WireMock.NET`.

To add the library, you must add the `WireMock.NET` NuGet package to your project, for example using `dotnet add package WireMock.Net`.

Once the package is ready, you can generate a test server in your Unit Tests class:

```cs
public class WireMockTests
{
    private WireMockServer _server;

    [OneTimeSetUp]
    public void OneTimeSetUp()
    {
        _server = WireMockServer.Start();
    }

    [SetUp]
    public void Setup()
    {
        _server.Reset();
    }

    [OneTimeTearDown]
    public void OneTimeTearDown()
    {
        _server.Stop();
    }
}
```

You can instantiate a new instance of `WireMockServer` in the `OneTimeSetUp` step, store it in a private field, and make it accessible to every test in the test class.

Before each test run, you can **reset the internal status of the mock server** by running the `Reset()` method. I‚Äôd suggest you reset the server to avoid unintentional internal status, but it all depends on what you want to do with the server instance.

Finally, remember to free up resources by calling the `Stop()` method in the `OneTimeTearDown` phase (but not during the `TearDown` phase: you still need the server to be on while running your tests!).

## Basic configuration of HTTP requests and responses with WireMock.NET

The basic structure of the definition of a mock response using WireMock.NET is made of two parts:

1.  Within the `Given` method, you define the HTTP Verb and URL path whose response is going to be mocked.
2.  Using `RespondWith` you define what the mock server must return when the endpoint specified in the `Given` step is called.

In the next example, you can see that the `_server` instance (the one I instantiated in the `OneTimeSetUp` phase, remember?) must return a specific body (`responseBody`) and the 200 HTTP Status Code when the `/api/books/42` endpoint is called.

```cs
string responseBody = @"
{
""Id"": 42,
""Title"": ""Life, the Universe and Everything""
}
";

_server
 .Given(Request.Create().WithPath("/api/books/42").UsingGet())
 .RespondWith(
  Response.Create()
 .WithStatusCode(200)
 .WithBody(responseBody)
 );
```

Similarly, you can define that an endpoint will return an error by changing its status code:

```cs
_server
.Given(Request.Create().WithPath("/api/books/42").UsingGet())
.RespondWith(
  Response.Create()
 .WithStatusCode(404)
);
```

All in all, both the request and the response are highly customizable: you can add HTTP Headers, delays, cookies, and much more.

Look closely; there‚Äôs one part that is missing: **What is the full URL?** We have declared only the path (`/api/books/42`) but have no info about the hostname and the port used to communicate.

## How to integrate WireMock.NET with a Moq-driven IHttpClientFactory

In order to have WireMock.NET react to an HTTP call, we have to call the exact URL - even the hostname and port must match. But when we create a mocked `HttpClient` - like we did [in this article](https://www.code4it.dev/blog/testing-httpclientfactory-moq/) - we don‚Äôt have a real hostname. So, how can we have WireMock.NET and `HttpClient` work together?

The answer is easy: since `WireMockServer.Start()` automatically picks a free port in your localhost, you don‚Äôt have to guess the port number, but you can reference the current instance of `_server`.

Once the `WireMockServer` is created, **internally it contains the reference to one or more URLs it will use to listen for HTTP requests**, intercepting the calls and **replying in place of a real server**. You can then use one of these ports to configure the `HttpClient` generated by the `HttpClientFactory`.

Let‚Äôs see the code:

```cs
[Test]
public async Task GetBookById_Should_HandleBadRequests()
{
    string baseUrl = _server.Url;

    HttpClient myHttpClient = new HttpClient() { BaseAddress = new Uri(baseUrl) };

    Mock<IHttpClientFactory> mockFactory = new Mock<IHttpClientFactory>();
    mockFactory.Setup(_ => _.CreateClient("books_client")).Returns(myHttpClient);

    _server
        .Given(Request.Create().WithPath("/api/books/42").UsingGet())
        .RespondWith(
            Response.Create()
            .WithStatusCode(404)
        );

    BookService service = new BookService(mockFactory.Object);

    Assert.CatchAsync<BookServiceException>(() => service.GetBookById(42));
}
```

First we access the base URL used by the mock server by accessing `_server.Url`.

We use that URL as a base address for the newly created instance of `HttpClient`.

Then, we create a mock of `IHttpClientFactory` and configure it to return the local instance of `HttpClient` whenever we call the `CreateClient` method with the specified name.

In the meanwhile, we define how the mock server must behave when an HTTP call to the specified path is intercepted.

Finally, we can pass the instance of the mock `IHttpClientFactory` to the `BookService`.

So, the key part to remember is that you can simply access the `Url` property (or, if you have configured it to handle many URLs, you can access the `Urls` property, that is an array of strings).

## Let WireMock.NET create the HttpClient for you

As suggested by [Stef](https://github.com/StefH) in the comments to this post, there‚Äôs actually another way to generate the HttpClient with the correct URL: let WireMock.NET do it for you.

Instead of doing

```cs
string baseUrl = _server.Url;

HttpClient myHttpClient = new HttpClient() { BaseAddress = new Uri(baseUrl) };
```

you can simplify the process by calling the `CreateClient` method:

```cs
HttpClient myHttpClient = _server.CreateClient();
```

Of course, you will still have to pass the instance to the mock of `IHttpClientFactory`.

## Further readings

It‚Äôs important to notice that **WireMock and WireMock.NET are two totally distinct things**: one is a platform, and one is a library, owned by a different group of people, that mimics some functionalities from the platform to help developers write better tests.

WireMock.NET is greatly integrated with many other libraries, such as xUnit, FluentAssertions, and .NET Aspire.

You can find the official repository on GitHub:

üîó [WireMock.Net | Github](https://github.com/WireMock-Net/WireMock.Net)

_This article first appeared on [Code4IT üêß](https://www.code4it.dev/)_

It‚Äôs important to remember that using an `HttpClientFactory` is generally more performant than instantiating a new `HttpClient`. Ever heard of _socket exhaustion_?

üîó [Use IHttpClientFactory to generate HttpClient instances | Code4IT](https://www.code4it.dev/csharptips/use-httpclientfactory-instead-of-httpclient/)

Finally, for the sake of this article I‚Äôve used Moq. However, there‚Äôs a similar library you can use: NSubstitute. The learning curve is quite flat: in the most common scenarios, it‚Äôs just a matter of syntax usage.

üîó [Moq vs NSubstitute: syntax cheat sheet | Code4IT](https://www.code4it.dev/blog/moq-vs-nsubstitute-syntax/)

## Wrapping up

In this article, we almost skipped all the basic stuff about WireMock.NET and tried to go straight to the point of integrating WireMock.NET with IHttpClientFactory.

There are lots of articles out there that explain how to use WireMock.NET - just remember that WireMock and WireMock.NET are not the same thing!

I hope you enjoyed this article! Let‚Äôs keep in touch on [LinkedIn](https://www.linkedin.com/in/BelloneDavide/) or [Twitter](https://twitter.com/BelloneDavide)! ü§úü§õ

Happy coding!

üêß

## Images
### featuredImage.png
A flat lay image on a dark world map background. On the left, a purple robot sticker, resembling the .NET bot mascot, is visible. In the center, a white note card framed with red lines displays "WireMock.NET", "Moq", and "IHttpClientFactory" handwritten in different colors, connected by blue arrows, illustrating their interaction. To the right, partially obscured by the note card, a Pok√©mon trading card featuring "Annihilape" is visible.